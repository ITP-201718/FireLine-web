'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var stream = require('stream');
var util = require('util');
var Decoder = require('./decoder');
var Simple = require('./simple');
var utils = require('./utils');
var constants = require('./constants');
var bignumber = require('bignumber.js');
var NoFilter = require('nofilter');

var MT = constants.MT;
var SYMS = constants.SYMS;

/**
 * Output the diagnostic format from a stream of CBOR bytes.
 *
 * @extends {stream.Transform}
 */

var Diagnose = function (_stream$Transform) {
  _inherits(Diagnose, _stream$Transform);

  /**
   * Creates an instance of Diagnose.
   *
   * @param {Object} [options={}] - options for creation
   * @param {string} [options.separator='\n'] - output between detected objects
   * @param {bool} [options.stream_errors=false] - put error info into the
   *   output stream
   * @param {number} [options.max_depth=-1] - -1 for "until you run out of
   *   memory".  Set this to a finite positive number for un-trusted inputs.
   *   Most standard inputs won't nest more than 100 or so levels; I've tested
   *   into the millions before running out of memory.
   */
  function Diagnose(options) {
    _classCallCheck(this, Diagnose);

    options = options || {};
    var separator = options.separator != null ? options.separator : '\n';
    delete options.separator;
    var stream_errors = options.stream_errors != null ? options.stream_errors : false;
    delete options.stream_errors;
    options.readableObjectMode = false;
    options.writableObjectMode = false;

    var _this = _possibleConstructorReturn(this, _stream$Transform.call(this, options));

    _this.float_bytes = -1;
    _this.separator = separator;
    _this.stream_errors = stream_errors;
    _this.parser = new Decoder(options);
    _this.parser.on('more-bytes', _this._on_more.bind(_this));
    _this.parser.on('value', _this._on_value.bind(_this));
    _this.parser.on('start', _this._on_start.bind(_this));
    _this.parser.on('stop', _this._on_stop.bind(_this));
    _this.parser.on('data', _this._on_data.bind(_this));
    _this.parser.on('error', _this._on_error.bind(_this));
    return _this;
  }

  Diagnose.prototype._transform = function _transform(fresh, encoding, cb) {
    return this.parser.write(fresh, encoding, cb);
  };

  Diagnose.prototype._flush = function _flush(cb) {
    var _this2 = this;

    return this.parser._flush(function (er) {
      if (_this2.stream_errors) {
        _this2._on_error(er);
        return cb();
      } else {
        return cb(er);
      }
    });
  };

  /**
   * Convenience function to return a string in diagnostic format.
   *
   * @param {(Buffer|string)} input - the CBOR bytes to format
   * @param {string} [encoding='hex'] - the encoding of input, ignored if
   *   input is Buffer
   * @param {commentCallback} cb - callback
   * @returns {Promise} if callback not specified
   */


  Diagnose.diagnose = function diagnose(input, encoding, cb) {
    if (input == null) {
      throw new Error('input required');
    }
    var opts = {};
    var encod = 'hex';
    switch (typeof encoding === 'undefined' ? 'undefined' : _typeof(encoding)) {
      case 'function':
        cb = encoding;
        encod = utils.guessEncoding(input);
        break;
      case 'object':
        opts = utils.extend({}, encoding);
        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);
        delete opts.encoding;
        break;
      default:
        encod = encoding != null ? encoding : 'hex';
    }
    var bs = new NoFilter();
    var d = new Diagnose(opts);
    var p = null;
    if (typeof cb === 'function') {
      d.on('end', function () {
        return cb(null, bs.toString('utf8'));
      });
      d.on('error', cb);
    } else {
      p = new Promise(function (resolve, reject) {
        d.on('end', function () {
          return resolve(bs.toString('utf8'));
        });
        return d.on('error', reject);
      });
    }
    d.pipe(bs);
    d.end(input, encod);
    return p;
  };

  Diagnose.prototype._on_error = function _on_error(er) {
    if (this.stream_errors) {
      return this.push(er.toString());
    } else {
      return this.emit('error', er);
    }
  };

  Diagnose.prototype._on_more = function _on_more(mt, len, parent_mt, pos) {
    if (mt === MT.SIMPLE_FLOAT) {
      return this.float_bytes = function () {
        switch (len) {
          case 2:
            return 1;
          case 4:
            return 2;
          case 8:
            return 3;
        }
      }();
    }
  };

  Diagnose.prototype._fore = function _fore(parent_mt, pos) {
    switch (parent_mt) {
      case MT.BYTE_STRING:
      case MT.UTF8_STRING:
      case MT.ARRAY:
        if (pos > 0) {
          return this.push(', ');
        }
        break;
      case MT.MAP:
        if (pos > 0) {
          if (pos % 2) {
            return this.push(': ');
          } else {
            return this.push(', ');
          }
        }
    }
  };

  Diagnose.prototype._on_value = function _on_value(val, parent_mt, pos) {
    if (val === SYMS.BREAK) {
      return;
    }
    this._fore(parent_mt, pos);
    return this.push(function () {
      switch (false) {
        case val !== SYMS.NULL:
          return 'null';
        case val !== SYMS.UNDEFINED:
          return 'undefined';
        case typeof val !== 'string':
          return JSON.stringify(val);
        case !(this.float_bytes > 0):
          var fb = this.float_bytes;
          this.float_bytes = -1;
          return util.inspect(val) + '_' + fb;
        case !Buffer.isBuffer(val):
          return 'h\'' + val.toString('hex') + '\'';
        case !(val instanceof bignumber):
          return val.toString();
        default:
          return util.inspect(val);
      }
    }.call(this));
  };

  Diagnose.prototype._on_start = function _on_start(mt, tag, parent_mt, pos) {
    this._fore(parent_mt, pos);
    this.push(function () {
      switch (mt) {
        case MT.TAG:
          return tag + '(';
        case MT.ARRAY:
          return '[';
        case MT.MAP:
          return '{';
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          return '(';
        default:
          // istanbul ignore next
          throw new Error('Unknown diagnostic type: ' + mt);
      }
    }());
    if (tag === SYMS.STREAM) {
      return this.push('_ ');
    }
  };

  Diagnose.prototype._on_stop = function _on_stop(mt) {
    return this.push(function () {
      switch (mt) {
        case MT.TAG:
          return ')';
        case MT.ARRAY:
          return ']';
        case MT.MAP:
          return '}';
        case MT.BYTE_STRING:
        case MT.UTF8_STRING:
          return ')';
        default:
          // istanbul ignore next
          throw new Error('Unknown diagnostic type: ' + mt);
      }
    }());
  };

  Diagnose.prototype._on_data = function _on_data() {
    return this.push(this.separator);
  };

  return Diagnose;
}(stream.Transform);

module.exports = Diagnose;
