'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var bignumber = require('bignumber.js');
var utils = require('./utils');
var url = require('url');

var MINUS_ONE = new bignumber(-1);
var TEN = new bignumber(10);
var TWO = new bignumber(2);

/**
 * A CBOR tagged item, where the tag does not have semantics specified at the
 * moment, or those semantics threw an error during parsing. Typically this will
 * be an extension point you're not yet expecting.
 */

var Tagged = function () {

  /**
   * Creates an instance of Tagged.
   *
   * @param {number} tag - the number of the tag
   * @param {any} value - the value inside the tag
   * @param {Error} err - the error that was thrown parsing the tag, or null
   */
  function Tagged(tag, value, err) {
    _classCallCheck(this, Tagged);

    this.tag = tag;
    this.value = value;
    this.err = err;
    if (typeof this.tag !== 'number') {
      throw new Error('Invalid tag type (' + _typeof(this.tag) + ')');
    }
    if (this.tag < 0 || (this.tag | 0) !== this.tag) {
      throw new Error('Tag must be a positive integer: ' + this.tag);
    }
  }

  /**
   * Convert to a String
   *
   * @returns {string} string of the form '1(2)'
   */


  Tagged.prototype.toString = function toString() {
    return this.tag + '(' + JSON.stringify(this.value) + ')';
  };

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   */


  Tagged.prototype.encodeCBOR = function encodeCBOR(gen) {
    gen._pushTag(this.tag);
    return gen.pushAny(this.value);
  };

  /**
   * If we have a converter for this type, do the conversion.  Some converters
   * are built-in.  Additional ones can be passed in.  If you want to remove
   * a built-in converter, pass a converter in whose value is 'null' instead
   * of a function.
   *
   * @param {Object} converters - keys in the object are a tag number, the value
   *   is a function that takes the decoded CBOR and returns a JavaScript value
   *   of the appropriate type.  Throw an exception in the function on errors.
   * @returns {any} - the converted item
   */


  Tagged.prototype.convert = function convert(converters) {
    var f = converters != null ? converters[this.tag] : void 0;
    if (typeof f !== 'function') {
      f = Tagged['_tag_' + this.tag];
      if (typeof f !== 'function') {
        return this;
      }
    }
    try {
      return f.call(Tagged, this.value);
    } catch (error) {
      this.err = error;
      return this;
    }
  };

  Tagged._tag_0 = function _tag_0(v) {
    return new Date(v);
  };

  Tagged._tag_1 = function _tag_1(v) {
    return new Date(v * 1000);
  };

  Tagged._tag_2 = function _tag_2(v) {
    return utils.bufferToBignumber(v);
  };

  Tagged._tag_3 = function _tag_3(v) {
    return MINUS_ONE.minus(utils.bufferToBignumber(v));
  };

  Tagged._tag_4 = function _tag_4(v) {
    return TEN.pow(v[0]).times(v[1]);
  };

  Tagged._tag_5 = function _tag_5(v) {
    return TWO.pow(v[0]).times(v[1]);
  };

  Tagged._tag_32 = function _tag_32(v) {
    return url.parse(v);
  };

  Tagged._tag_35 = function _tag_35(v) {
    return new RegExp(v);
  };

  return Tagged;
}();

module.exports = Tagged;
