'use strict';

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var encoder = require('./encoder');
var decoder = require('./decoder');
var constants = require('./constants');
var MT = constants.MT;

/**
 * Wrapper around a JavaScript Map object that allows the keys to be
 * any complex type.  The base Map object allows this, but will only
 * compare the keys by identity, not by value.  CborMap translates keys
 * to CBOR first (and base64's them to ensure by-value comparison).
 *
 * This is not a subclass of Object, because it would be tough to get
 * the semantics to be an exact match.
 *
 * @class CborMap
 * @extends {Map}
 */

var CborMap = function (_Map) {
  _inherits(CborMap, _Map);

  /**
   * Creates an instance of CborMap.
   * @param {Iterable<Array<any, any>>} args An Array or other iterable object
   *   whose elements are key-value pairs (arrays with two elements, e.g.
   *   <code>[[ 1, 'one' ],[ 2, 'two' ]]</code>). Each key-value pair is added
   *   to the new CborMap; null values are treated as undefined.
   */
  function CborMap(iterable) {
    _classCallCheck(this, CborMap);

    return _possibleConstructorReturn(this, _Map.call(this, iterable));
  }

  /**
   * @private
   */


  CborMap._encode = function _encode(key) {
    return encoder.encodeCanonical(key).toString('base64');
  };

  /**
   * @private
   */


  CborMap._decode = function _decode(key) {
    return decoder.decodeFirstSync(key, 'base64');
  };

  /**
   * Retrieve a specified element.
   *
   * @param {any} key The key identifying the element to retrieve.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {any} The element if it exists, or <code>undefined</code>.
   */


  CborMap.prototype.get = function get(key) {
    return _Map.prototype.get.call(this, CborMap._encode(key));
  };

  /**
   * Adds or updates an element with a specified key and value.
   *
   * @param {any} key The key identifying the element to store.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @param {any} val The element to store
   */


  CborMap.prototype.set = function set(key, val) {
    return _Map.prototype.set.call(this, CborMap._encode(key), val);
  };

  /**
   * Removes the specified element.
   *
   * @param {any} key The key identifying the element to delete.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {boolean}
   */


  CborMap.prototype.delete = function _delete(key) {
    return _Map.prototype.delete.call(this, CborMap._encode(key));
  };

  /**
   * Does an element with the specified key exist?
   *
   * @param {any} key The key identifying the element to check.
   *   Can be any type, which will be serialized into CBOR and compared by
   *   value.
   * @returns {boolean}
   */


  CborMap.prototype.has = function has(key) {
    return _Map.prototype.has.call(this, CborMap._encode(key));
  };

  /**
   * Returns a new Iterator object that contains the keys for each element
   * in the Map object in insertion order.  The keys are decoded into their
   * original format.
   *
   * @returns {Iterator<any>}
   */


  CborMap.prototype.keys = /*#__PURE__*/regeneratorRuntime.mark(function keys() {
    var _iterator, _isArray, _i, _ref, k;

    return regeneratorRuntime.wrap(function keys$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            _iterator = _Map.prototype.keys.call(this), _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();

          case 1:
            if (!_isArray) {
              _context.next = 7;
              break;
            }

            if (!(_i >= _iterator.length)) {
              _context.next = 4;
              break;
            }

            return _context.abrupt('break', 16);

          case 4:
            _ref = _iterator[_i++];
            _context.next = 11;
            break;

          case 7:
            _i = _iterator.next();

            if (!_i.done) {
              _context.next = 10;
              break;
            }

            return _context.abrupt('break', 16);

          case 10:
            _ref = _i.value;

          case 11:
            k = _ref;
            _context.next = 14;
            return CborMap._decode(k);

          case 14:
            _context.next = 1;
            break;

          case 16:
          case 'end':
            return _context.stop();
        }
      }
    }, keys, this);
  });

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {Iterator.<Array.<any, any>>}
   */

  CborMap.prototype.entries = /*#__PURE__*/regeneratorRuntime.mark(function entries() {
    var _iterator2, _isArray2, _i2, _ref2, kv;

    return regeneratorRuntime.wrap(function entries$(_context2) {
      while (1) {
        switch (_context2.prev = _context2.next) {
          case 0:
            _iterator2 = _Map.prototype.entries.call(this), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();

          case 1:
            if (!_isArray2) {
              _context2.next = 7;
              break;
            }

            if (!(_i2 >= _iterator2.length)) {
              _context2.next = 4;
              break;
            }

            return _context2.abrupt('break', 16);

          case 4:
            _ref2 = _iterator2[_i2++];
            _context2.next = 11;
            break;

          case 7:
            _i2 = _iterator2.next();

            if (!_i2.done) {
              _context2.next = 10;
              break;
            }

            return _context2.abrupt('break', 16);

          case 10:
            _ref2 = _i2.value;

          case 11:
            kv = _ref2;
            _context2.next = 14;
            return [CborMap._decode(kv[0]), kv[1]];

          case 14:
            _context2.next = 1;
            break;

          case 16:
          case 'end':
            return _context2.stop();
        }
      }
    }, entries, this);
  });

  /**
   * Returns a new Iterator object that contains the [key, value] pairs for
   * each element in the Map object in insertion order.
   *
   * @returns {Iterator.<Array.<any>>}
   */

  CborMap.prototype[Symbol.iterator] = function () {
    return this.entries();
  };

  /**
   * Executes a provided function once per each key/value pair in the Map
   * object, in insertion order.
   *
   * @param {function(any, any, CborMap)} fun Function to execute for each
   *  element, which takes a value, a key, and the Map being traversed.
   * @param {any} thisArg Value to use as this when executing callback
   */


  CborMap.prototype.forEach = function forEach(fun, thisArg) {
    if (typeof fun !== 'function') {
      throw new TypeError('Must be function');
    }
    for (var _iterator3 = _Map.prototype.entries.call(this), _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
      var _ref3;

      if (_isArray3) {
        if (_i3 >= _iterator3.length) break;
        _ref3 = _iterator3[_i3++];
      } else {
        _i3 = _iterator3.next();
        if (_i3.done) break;
        _ref3 = _i3.value;
      }

      var kv = _ref3;

      fun.call(this, kv[1], CborMap._decode(kv[0]), this);
    }
  };

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   * @returns {boolean} true on success
   */


  CborMap.prototype.encodeCBOR = function encodeCBOR(gen) {
    if (!gen._pushInt(this.size, MT.MAP)) {
      return false;
    }
    if (gen.canonical) {
      var _entries = Array.from(_Map.prototype.entries.call(this)).map(function (kv) {
        return [new Buffer(kv[0], 'base64'), kv[1]];
      });
      _entries.sort(function (a, b) {
        return a[0].compare(b[0]);
      });
      for (var _iterator4 = _entries, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var kv = _ref4;

        if (!(gen.push(kv[0]) && gen.pushAny(kv[1]))) {
          return false;
        }
      }
    } else {
      for (var _iterator5 = _Map.prototype.entries.call(this), _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref5 = _i5.value;
        }

        var _kv = _ref5;

        if (!(gen.push(new Buffer(_kv[0], 'base64')) && gen.pushAny(_kv[1]))) {
          return false;
        }
      }
    }
    return true;
  };

  return CborMap;
}(Map);

module.exports = CborMap;
