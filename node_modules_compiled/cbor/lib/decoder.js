'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var BinaryParseStream = require('../vendor/binary-parse-stream');
var Tagged = require('./tagged');
var Simple = require('./simple');
var utils = require('./utils');
var bignumber = require('bignumber.js');
var NoFilter = require('nofilter');
var constants = require('./constants');
// Do not fix this if you want to support node v4
var MT = constants.MT;
var NUMBYTES = constants.NUMBYTES;
var SIMPLE = constants.SIMPLE;
var SYMS = constants.SYMS;

var NEG_ONE = new bignumber(-1);
var NEG_MAX = NEG_ONE.minus(new bignumber(Number.MAX_SAFE_INTEGER.toString(16), 16));
var COUNT = Symbol('count');
var PENDING_KEY = Symbol('pending_key');
var MAJOR = Symbol('major type');
var ERROR = Symbol('error');
var NOT_FOUND = Symbol('not found');

function parentArray(parent, typ, count) {
  var a = [];
  a[COUNT] = count;
  a[SYMS.PARENT] = parent;
  a[MAJOR] = typ;
  return a;
}

function parentBufferStream(parent, typ) {
  var b = new NoFilter();
  b[SYMS.PARENT] = parent;
  b[MAJOR] = typ;
  return b;
}

/**
 * Decode a stream of CBOR bytes by transforming them into equivalent
 * JavaScript data.  Because of the limitations of Node object streams,
 * special symbols are emitted instead of NULL or UNDEFINED.  Fix those
 * up by calling {@link Decoder.nullcheck}.
 *
 * @extends {BinaryParseStream}
 */

var Decoder = function (_BinaryParseStream) {
  _inherits(Decoder, _BinaryParseStream);

  /**
   * Create a parsing stream.
   *
   * @param {object} [options={}]
   * @param {number} [options.max_depth=-1] - the maximum depth to parse.
   *   Use -1 for "until you run out of memory".  Set this to a finite
   *   positive number for un-trusted inputs.  Most standard inputs won't nest
   *   more than 100 or so levels; I've tested into the millions before
   *   running out of memory.
   * @param {object=} options.tags - mapping from tag number to function(v),
   *   where v is the decoded value that comes after the tag, and where the
   *   function returns the correctly-created value for that tag.
   */
  function Decoder(options) {
    _classCallCheck(this, Decoder);

    options = options || {};
    var tags = options.tags;
    delete options.tags;
    var max_depth = options.max_depth != null ? options.max_depth : -1;
    delete options.max_depth;

    var _this = _possibleConstructorReturn(this, _BinaryParseStream.call(this, options));

    _this.running = true;
    _this.max_depth = max_depth;
    _this.tags = tags;
    return _this;
  }

  /**
   * Check the given value for a symbol encoding a NULL or UNDEFINED value in
   * the CBOR stream.
   *
   * @static
   * @param {any} val - the value to check
   * @returns {any} the corrected value
   *
   * @example
   * myDecoder.on('data', function(val) {
   *   val = Decoder.nullcheck(val);
   *   ...
   * });
   */


  Decoder.nullcheck = function nullcheck(val) {
    switch (val) {
      case SYMS.NULL:
        return null;
      case SYMS.UNDEFINED:
        return undefined;
      case NOT_FOUND:
        throw new Error('Value not found');
      default:
        return val;
    }
  };

  /**
   * Decode the first CBOR item in the input, synchronously.  This will throw an
   * exception if the input is not valid CBOR.
   *
   * @static
   * @param {(string|Buffer)} input
   * @param {object} [options={encoding: 'hex'}]
   * @param {string} [options.encoding: 'hex'] - The encoding of the input.
   *   Ignored if input is a Buffer.
   * @returns {any} - the decoded value
   */


  Decoder.decodeFirstSync = function decodeFirstSync(input, options) {
    options = options || { encoding: 'hex' };
    var opts = {};
    var encod = void 0;
    switch (typeof options === 'undefined' ? 'undefined' : _typeof(options)) {
      case 'string':
        encod = options;
        break;
      case 'object':
        opts = utils.extend({}, options);
        encod = opts.encoding;
        delete opts.encoding;
        break;
    }
    var c = new Decoder(opts);
    var s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));
    var parser = c._parse();
    var state = parser.next();
    while (!state.done) {
      var b = s.read(state.value);
      if (b == null || b.length !== state.value) {
        throw new Error('Insufficient data');
      }
      state = parser.next(b);
    }
    return Decoder.nullcheck(state.value);
  };

  /**
   * Decode all of the CBOR items in the input into an array.  This will throw
   * an exception if the input is not valid CBOR; a zero-length input will
   * return an empty array.
   *
   * @static
   * @param {(string|Buffer)} input
   * @param {(string|Object)} [options={encoding: 'hex'}]
   * @param {string} [options.encoding: 'hex'] - The encoding of the input.
   *   Ignored if input is a Buffer.
   * @returns {Array} - Array of all found items
   */


  Decoder.decodeAllSync = function decodeAllSync(input, options) {
    options = options || { encoding: 'hex' };
    var opts = {};
    var encod = void 0;
    switch (typeof options === 'undefined' ? 'undefined' : _typeof(options)) {
      case 'string':
        encod = options;
        break;
      case 'object':
        opts = utils.extend({}, options);
        encod = opts.encoding;
        delete opts.encoding;
    }
    var c = new Decoder(opts);
    var s = new NoFilter(input, encod != null ? encod : utils.guessEncoding(input));
    var res = [];
    while (s.length > 0) {
      var parser = c._parse();
      var state = parser.next();
      while (!state.done) {
        var b = s.read(state.value);
        if (b == null || b.length !== state.value) {
          throw new Error('Insufficient data');
        }
        state = parser.next(b);
      }
      res.push(Decoder.nullcheck(state.value));
    }
    return res;
  };

  /**
   * @callback decodeCallback
   * @param {Error} error - if one was generated
   * @param {any} value - the decoded value
   */

  /**
   * Decode the first CBOR item in the input.  This will error if there are more
   * bytes left over at the end, and optionally if there were no valid CBOR
   * bytes in the input.  Emits the {Decoder.NOT_FOUND} Symbol in the callback
   * if no data was found and the `required` option is false.
   *
   * @static
   * @param {(string|Buffer)} input - the input to parse
   * @param {(function|string|Object)} options
   * @param {string} [options.encoding: 'hex'] - The encoding of the input.
   *   Ignored if input is a Buffer.
   * @param {decodeCallback} cb
   * @returns {Promise} if no cb specified
   */


  Decoder.decodeFirst = function decodeFirst(input, options, cb) {
    var opts = {};
    var required = false;
    var encod = 'hex';
    switch (typeof options === 'undefined' ? 'undefined' : _typeof(options)) {
      case 'function':
        cb = options;
        encod = utils.guessEncoding(input);
        break;
      case 'string':
        encod = options;
        break;
      case 'object':
        opts = utils.extend({}, options);
        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);
        delete opts.encoding;
        required = opts.required != null ? opts.required : false;
        delete opts.required;
    }
    var c = new Decoder(opts);
    var p = void 0;
    var v = NOT_FOUND;
    c.on('data', function (val) {
      v = Decoder.nullcheck(val);
      c.close();
    });
    if (typeof cb === 'function') {
      c.once('error', function (er) {
        var u = v;
        v = ERROR;
        c.close();
        return cb(er, u);
      });
      c.once('end', function () {
        switch (v) {
          case NOT_FOUND:
            if (required) {
              return cb(new Error('No CBOR found'));
            } else {
              return cb(null, v);
            }
          case ERROR:
            return void 0;
          default:
            return cb(null, v);
        }
      });
    } else {
      p = new Promise(function (resolve, reject) {
        c.once('error', function (er) {
          v = ERROR;
          c.close();
          return reject(er);
        });
        return c.once('end', function () {
          switch (v) {
            case NOT_FOUND:
              if (required) {
                return reject(new Error('No CBOR found'));
              } else {
                return resolve(v);
              }
            case ERROR:
              return void 0;
            default:
              return resolve(v);
          }
        });
      });
    }
    c.end(input, encod);
    return p;
  };

  /**
   * @callback decodeAllCallback
   * @param {Error} error - if one was generated
   * @param {Array} value - all of the decoded values, wrapped in an Array
   */

  /**
   * Decode all of the CBOR items in the input.  This will error if there are
   * more bytes left over at the end.
   *
   * @static
   * @param {(string|Buffer)} input - the input to parse
   * @param {(string|Object)} options - Decoding options.
   *   If string, the input encoding.
   * @param {decodeAllCallback} cb
   * @returns {Promise} if no callback
   */


  Decoder.decodeAll = function decodeAll(input, options, cb) {
    var opts = {};
    var encod = 'hex';
    switch (typeof options === 'undefined' ? 'undefined' : _typeof(options)) {
      case 'function':
        cb = options;
        encod = utils.guessEncoding(input);
        break;
      case 'string':
        encod = options;
        break;
      case 'object':
        opts = utils.extend({}, options);
        encod = opts.encoding != null ? opts.encoding : utils.guessEncoding(input);
        delete opts.encoding;
    }
    var c = new Decoder(opts);
    var p = void 0;
    var vals = [];
    c.on('data', function (val) {
      return vals.push(Decoder.nullcheck(val));
    });
    if (typeof cb === 'function') {
      c.on('error', cb);
      c.on('end', function () {
        return cb(null, vals);
      });
    } else {
      p = new Promise(function (resolve, reject) {
        c.on('error', reject);
        c.on('end', function () {
          return resolve(vals);
        });
      });
    }
    c.end(input, encod);
    return p;
  };

  /**
   * Stop processing
   */


  Decoder.prototype.close = function close() {
    this.running = false;
    this.__fresh = true;
  };

  Decoder.prototype._parse = /*#__PURE__*/regeneratorRuntime.mark(function _parse() {
    var parent, depth, val, octet, mt, ai, parent_major, parent_length, numbytes, buf, again, pm, allstrings, i, len, _i, _len, _i2, _len2, t, old;

    return regeneratorRuntime.wrap(function _parse$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            parent = null;
            depth = 0;
            val = null;

          case 3:
            if (!true) {
              _context.next = 140;
              break;
            }

            if (!(this.max_depth >= 0 && depth > this.max_depth)) {
              _context.next = 6;
              break;
            }

            throw new Error('Maximum depth ' + this.max_depth + ' exceeded');

          case 6:
            _context.next = 8;
            return 1;

          case 8:
            octet = _context.sent[0];

            if (this.running) {
              _context.next = 11;
              break;
            }

            throw new Error('Unexpected data: 0x' + octet.toString(16));

          case 11:
            mt = octet >> 5;
            ai = octet & 0x1f;
            parent_major = parent != null ? parent[MAJOR] : undefined;
            parent_length = parent != null ? parent.length : undefined;
            _context.t0 = ai;
            _context.next = _context.t0 === NUMBYTES.ONE ? 18 : _context.t0 === NUMBYTES.TWO ? 23 : _context.t0 === NUMBYTES.FOUR ? 23 : _context.t0 === NUMBYTES.EIGHT ? 23 : _context.t0 === 28 ? 30 : _context.t0 === 29 ? 30 : _context.t0 === 30 ? 30 : _context.t0 === NUMBYTES.INDEFINITE ? 32 : 34;
            break;

          case 18:
            this.emit('more-bytes', mt, 1, parent_major, parent_length);
            _context.next = 21;
            return 1;

          case 21:
            val = _context.sent[0];
            return _context.abrupt('break', 35);

          case 23:
            numbytes = 1 << ai - 24;

            this.emit('more-bytes', mt, numbytes, parent_major, parent_length);
            _context.next = 27;
            return numbytes;

          case 27:
            buf = _context.sent;

            val = mt === MT.SIMPLE_FLOAT ? buf : utils.parseCBORint(ai, buf);
            return _context.abrupt('break', 35);

          case 30:
            this.running = false;
            throw new Error('Additional info not implemented: ' + ai);

          case 32:
            val = -1;
            return _context.abrupt('break', 35);

          case 34:
            val = ai;

          case 35:
            _context.t1 = mt;
            _context.next = _context.t1 === MT.POS_INT ? 38 : _context.t1 === MT.NEG_INT ? 39 : _context.t1 === MT.BYTE_STRING ? 41 : _context.t1 === MT.UTF8_STRING ? 41 : _context.t1 === MT.ARRAY ? 57 : _context.t1 === MT.MAP ? 57 : _context.t1 === MT.TAG ? 71 : _context.t1 === MT.SIMPLE_FLOAT ? 76 : 77;
            break;

          case 38:
            return _context.abrupt('break', 77);

          case 39:
            if (val === Number.MAX_SAFE_INTEGER) {
              val = NEG_MAX;
            } else if (val instanceof bignumber) {
              val = NEG_ONE.minus(val);
            } else {
              val = -1 - val;
            }
            return _context.abrupt('break', 77);

          case 41:
            _context.t2 = val;
            _context.next = _context.t2 === 0 ? 44 : _context.t2 === -1 ? 47 : 51;
            break;

          case 44:
            this.emit('start-string', mt, val, parent_major, parent_length);
            val = mt === MT.BYTE_STRING ? new Buffer(0) : '';
            return _context.abrupt('break', 56);

          case 47:
            this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
            parent = parentBufferStream(parent, mt);
            depth++;
            return _context.abrupt('continue', 3);

          case 51:
            this.emit('start-string', mt, val, parent_major, parent_length);
            _context.next = 54;
            return val;

          case 54:
            val = _context.sent;

            if (mt === MT.UTF8_STRING) {
              val = val.toString('utf-8');
            }

          case 56:
            return _context.abrupt('break', 77);

          case 57:
            _context.t3 = val;
            _context.next = _context.t3 === 0 ? 60 : _context.t3 === -1 ? 62 : 66;
            break;

          case 60:
            val = mt === MT.MAP ? {} : [];
            return _context.abrupt('break', 70);

          case 62:
            this.emit('start', mt, SYMS.STREAM, parent_major, parent_length);
            parent = parentArray(parent, mt, -1);
            depth++;
            return _context.abrupt('continue', 3);

          case 66:
            this.emit('start', mt, val, parent_major, parent_length);
            parent = parentArray(parent, mt, val * (mt - 3));
            depth++;
            return _context.abrupt('continue', 3);

          case 70:
            return _context.abrupt('break', 77);

          case 71:
            this.emit('start', mt, val, parent_major, parent_length);
            parent = parentArray(parent, mt, 1);
            parent.push(val);
            depth++;
            return _context.abrupt('continue', 3);

          case 76:
            if (typeof val === 'number') {
              val = Simple.decode(val, parent != null);
            } else {
              val = utils.parseCBORfloat(val);
            }

          case 77:
            this.emit('value', val, parent_major, parent_length, ai);
            again = false;

          case 79:
            if (!(parent != null)) {
              _context.next = 136;
              break;
            }

            _context.t4 = false;
            _context.next = _context.t4 === (val !== SYMS.BREAK) ? 83 : _context.t4 === !Array.isArray(parent) ? 85 : _context.t4 === !(parent instanceof NoFilter) ? 87 : 92;
            break;

          case 83:
            parent[COUNT] = 1;
            return _context.abrupt('break', 92);

          case 85:
            parent.push(val);
            return _context.abrupt('break', 92);

          case 87:
            pm = parent[MAJOR];

            if (!(pm != null && pm !== mt)) {
              _context.next = 91;
              break;
            }

            this.running = false;
            throw new Error('Invalid major type in indefinite encoding');

          case 91:
            parent.write(val);

          case 92:
            if (!(--parent[COUNT] !== 0)) {
              _context.next = 95;
              break;
            }

            again = true;
            return _context.abrupt('break', 136);

          case 95:
            --depth;
            delete parent[COUNT];
            this.emit('stop', parent[MAJOR]);

            if (!Array.isArray(parent)) {
              _context.next = 122;
              break;
            }

            _context.t5 = parent[MAJOR];
            _context.next = _context.t5 === MT.ARRAY ? 102 : _context.t5 === MT.MAP ? 104 : _context.t5 === MT.TAG ? 117 : 120;
            break;

          case 102:
            val = parent;
            return _context.abrupt('break', 120);

          case 104:
            allstrings = true;

            if (!(parent.length % 2 !== 0)) {
              _context.next = 107;
              break;
            }

            throw new Error('Invalid map length: ' + parent.length);

          case 107:
            i = 0, len = parent.length;

          case 108:
            if (!(i < len)) {
              _context.next = 115;
              break;
            }

            if (!(typeof parent[i] !== 'string')) {
              _context.next = 112;
              break;
            }

            allstrings = false;
            return _context.abrupt('break', 115);

          case 112:
            i += 2;
            _context.next = 108;
            break;

          case 115:
            if (allstrings) {
              val = {};
              for (_i = 0, _len = parent.length; _i < _len; _i += 2) {
                val[parent[_i]] = parent[_i + 1];
              }
            } else {
              val = new Map();
              for (_i2 = 0, _len2 = parent.length; _i2 < _len2; _i2 += 2) {
                val.set(parent[_i2], parent[_i2 + 1]);
              }
            }
            return _context.abrupt('break', 120);

          case 117:
            t = new Tagged(parent[0], parent[1]);

            val = t.convert(this.tags);
            return _context.abrupt('break', 120);

          case 120:
            _context.next = 130;
            break;

          case 122:
            if (!(parent instanceof NoFilter)) {
              _context.next = 130;
              break;
            }

            _context.t6 = parent[MAJOR];
            _context.next = _context.t6 === MT.BYTE_STRING ? 126 : _context.t6 === MT.UTF8_STRING ? 128 : 130;
            break;

          case 126:
            val = parent.slice();
            return _context.abrupt('break', 130);

          case 128:
            val = parent.toString('utf-8');
            return _context.abrupt('break', 130);

          case 130:
            old = parent;

            parent = parent[SYMS.PARENT];
            delete old[SYMS.PARENT];
            delete old[MAJOR];
            _context.next = 79;
            break;

          case 136:
            if (again) {
              _context.next = 138;
              break;
            }

            return _context.abrupt('return', val);

          case 138:
            _context.next = 3;
            break;

          case 140:
          case 'end':
            return _context.stop();
        }
      }
    }, _parse, this);
  });
  return Decoder;
}(BinaryParseStream);

Decoder.NOT_FOUND = NOT_FOUND;
module.exports = Decoder;
