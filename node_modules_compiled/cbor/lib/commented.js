'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var stream = require('stream');
var util = require('util');
var utils = require('./utils');
var Simple = require('./simple');
var Decoder = require('./decoder');
var constants = require('./constants');
var bignumber = require('bignumber.js');
var NoFilter = require('nofilter');

var MT = constants.MT;
var NUMBYTES = constants.NUMBYTES;
var SYMS = constants.SYMS;

function plural(c) {
  if (c > 1) {
    return 's';
  } else {
    return '';
  }
}

/**
 * Generate the expanded format of RFC 7049, section 2.2.1
 *
 * @extends {stream.Transform}
 */

var Commented = function (_stream$Transform) {
  _inherits(Commented, _stream$Transform);

  /**
   * Create a CBOR commenter.
   *
   * @param {any} [options={}] - Stream options
   * @param {bool} [options.max_depth=10] - how many times to indent the dashes
   */
  function Commented(options) {
    _classCallCheck(this, Commented);

    options = options || {};
    options.readableObjectMode = false;
    options.writableObjectMode = false;
    var max_depth = options.max_depth != null ? options.max_depth : 10;
    delete options.max_depth;

    var _this = _possibleConstructorReturn(this, _stream$Transform.call(this, options));

    _this.depth = 1;
    _this.max_depth = max_depth;
    _this.all = new NoFilter();
    _this.parser = new Decoder(options);
    _this.parser.on('value', _this._on_value.bind(_this));
    _this.parser.on('start', _this._on_start.bind(_this));
    _this.parser.on('start-string', _this._on_start_string.bind(_this));
    _this.parser.on('stop', _this._on_stop.bind(_this));
    _this.parser.on('more-bytes', _this._on_more.bind(_this));
    _this.parser.on('error', _this._on_error.bind(_this));
    _this.parser.on('data', _this._on_data.bind(_this));
    _this.parser.bs.on('read', _this._on_read.bind(_this));
    return _this;
  }

  /**
   * @private
   */


  Commented.prototype._transform = function _transform(fresh, encoding, cb) {
    this.parser.write(fresh, encoding, cb);
  };

  /**
   * @private
   */


  Commented.prototype._flush = function _flush(cb) {
    // TODO: find the test that covers this, and look at the return value
    return this.parser._flush(cb);
  };

  /**
   * @callback commentCallback
   * @param {Error} error - if one was generated
   * @param {string} commented - the comment string
   */

  /**
   * Comment on an input Buffer or string, creating a string passed to the
   * callback.  If callback not specified, a promise is returned.
   *
   * @static
   * @param {(string|Buffer|NoFilter)} input
   * @param {(string|Object|function)} options
   * @param {number} [options.max_depth=10] how many times to indent the dashes
   * @param {commentCallback=} cb
   * @returns {Promise} if cb not specified
   */


  Commented.comment = function comment(input, options, cb) {
    if (input == null) {
      throw new Error('input required');
    }
    var encoding = typeof input === 'string' ? 'hex' : void 0;
    var max_depth = 10;
    switch (typeof options === 'undefined' ? 'undefined' : _typeof(options)) {
      case 'function':
        cb = options;
        break;
      case 'string':
        encoding = options;
        break;
      case 'number':
        max_depth = options;
        break;
      case 'object':
        var ref1 = options.encoding;
        var ref2 = options.max_depth;
        encoding = ref1 != null ? ref1 : encoding;
        max_depth = ref2 != null ? ref2 : max_depth;
        break;
      case 'undefined':
        break;
      default:
        throw new Error('Unknown option type');
    }
    var bs = new NoFilter();
    var d = new Commented({
      max_depth: max_depth
    });
    var p = null;
    if (typeof cb === 'function') {
      d.on('end', function () {
        cb(null, bs.toString('utf8'));
      });
      d.on('error', cb);
    } else {
      p = new Promise(function (resolve, reject) {
        d.on('end', function () {
          resolve(bs.toString('utf8'));
        });
        return d.on('error', reject);
      });
    }
    d.pipe(bs);
    d.end(input, encoding);
    return p;
  };

  /**
   * @private
   */


  Commented.prototype._on_error = function _on_error(er) {
    return this.push('ERROR: ') && this.push(er.toString()) && this.push('\n');
  };

  /**
   * @private
   */


  Commented.prototype._on_read = function _on_read(buf) {
    this.all.write(buf);
    var hex = buf.toString('hex');
    this.push(new Array(this.depth + 1).join('  '));
    this.push(hex);
    var ind = (this.max_depth - this.depth) * 2;
    ind -= hex.length;
    if (ind < 1) {
      ind = 1;
    }
    this.push(new Array(ind + 1).join(' '));
    return this.push('-- ');
  };

  /**
   * @private
   */


  Commented.prototype._on_more = function _on_more(mt, len, parent_mt, pos) {
    this.depth++;
    var desc = '';
    switch (mt) {
      case MT.POS_INT:
        desc = 'Positive number,';
        break;
      case MT.NEG_INT:
        desc = 'Negative number,';
        break;
      case MT.ARRAY:
        desc = 'Array, length';
        break;
      case MT.MAP:
        desc = 'Map, count';
        break;
      case MT.BYTE_STRING:
        desc = 'Bytes, length';
        break;
      case MT.UTF8_STRING:
        desc = 'String, length';
        break;
      case MT.SIMPLE_FLOAT:
        if (len === 1) {
          desc = 'Simple value,';
        } else {
          desc = 'Float,';
        }
        break;
    }
    return this.push(desc + ' next ' + len + ' byte' + plural(len) + '\n');
  };

  /**
   * @private
   */


  Commented.prototype._on_start_string = function _on_start_string(mt, tag, parent_mt, pos) {
    this.depth++;
    var desc = '';
    switch (mt) {
      case MT.BYTE_STRING:
        desc = 'Bytes, length: ' + tag;
        break;
      case MT.UTF8_STRING:
        desc = 'String, length: ' + tag.toString();
        break;
    }
    return this.push(desc + '\n');
  };

  /**
   * @private
   */


  Commented.prototype._on_start = function _on_start(mt, tag, parent_mt, pos) {
    this.depth++;
    if (tag !== SYMS.BREAK) {
      this.push(function () {
        switch (parent_mt) {
          case MT.ARRAY:
            return '[' + pos + '], ';
          case MT.MAP:
            if (pos % 2) {
              return '{Val:' + Math.floor(pos / 2) + '}, ';
            } else {
              return '{Key:' + Math.floor(pos / 2) + '}, ';
            }
        }
      }());
    }
    this.push(function () {
      switch (mt) {
        case MT.TAG:
          return 'Tag #' + tag;
        case MT.ARRAY:
          if (tag === SYMS.STREAM) {
            return 'Array (streaming)';
          } else {
            return 'Array, ' + tag + ' item' + plural(tag);
          }
        case MT.MAP:
          if (tag === SYMS.STREAM) {
            return 'Map (streaming)';
          } else {
            return 'Map, ' + tag + ' pair' + plural(tag);
          }
        case MT.BYTE_STRING:
          return 'Bytes (streaming)';
        case MT.UTF8_STRING:
          return 'String (streaming)';
      }
    }());
    return this.push('\n');
  };

  /**
   * @private
   */


  Commented.prototype._on_stop = function _on_stop(mt) {
    return this.depth--;
  };

  /**
   * @private
   */


  Commented.prototype._on_value = function _on_value(val, parent_mt, pos, ai) {
    if (val !== SYMS.BREAK) {
      this.push(function () {
        switch (parent_mt) {
          case MT.ARRAY:
            return '[' + pos + '], ';
          case MT.MAP:
            if (pos % 2) {
              return '{Val:' + Math.floor(pos / 2) + '}, ';
            } else {
              return '{Key:' + Math.floor(pos / 2) + '}, ';
            }
        }
      }());
    }

    if (val === SYMS.BREAK) {
      this.push('BREAK\n');
    } else if (val === SYMS.NULL) {
      this.push('null\n');
    } else if (val === SYMS.UNDEFINED) {
      this.push('undefined\n');
    } else if (typeof val === 'string') {
      this.depth--;
      if (val.length > 0) {
        this.push(JSON.stringify(val));
        this.push('\n');
      }
    } else if (Buffer.isBuffer(val)) {
      this.depth--;
      if (val.length > 0) {
        this.push(val.toString('hex'));
        this.push('\n');
      }
    } else if (val instanceof bignumber) {
      this.push(val.toString());
      this.push('\n');
    } else {
      this.push(util.inspect(val));
      this.push('\n');
    }

    switch (ai) {
      case NUMBYTES.ONE:
      case NUMBYTES.TWO:
      case NUMBYTES.FOUR:
      case NUMBYTES.EIGHT:
        this.depth--;
    }
  };

  /**
   * @private
   */


  Commented.prototype._on_data = function _on_data() {
    this.push('0x');
    this.push(this.all.read().toString('hex'));
    return this.push('\n');
  };

  return Commented;
}(stream.Transform);

module.exports = Commented;
