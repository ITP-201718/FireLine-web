'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var stream = require('stream');
var url = require('url');
var bignumber = require('bignumber.js');
var NoFilter = require('nofilter');
var Tagged = require('./tagged');
var Simple = require('./simple');
var utils = require('./utils');

var constants = require('./constants');
var MT = constants.MT;
var NUMBYTES = constants.NUMBYTES;
var SHIFT32 = constants.SHIFT32;
var SYMS = constants.SYMS;
var TAG = constants.TAG;
var HALF = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.TWO;
var FLOAT = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.FOUR;
var DOUBLE = constants.MT.SIMPLE_FLOAT << 5 | constants.NUMBYTES.EIGHT;
var TRUE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.TRUE;
var FALSE = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.FALSE;
var UNDEFINED = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.UNDEFINED;
var NULL = constants.MT.SIMPLE_FLOAT << 5 | constants.SIMPLE.NULL;

var MAXINT_BN = new bignumber('0x20000000000000');
var BUF_NAN = new Buffer('f97e00', 'hex');
var BUF_INF_NEG = new Buffer('f9fc00', 'hex');
var BUF_INF_POS = new Buffer('f97c00', 'hex');
var LOOP_DETECT = Symbol('CBOR_LOOP_DETECT');

/**
 * Transform JavaScript values into CBOR bytes.  The `Writable` side of
 * the stream is in object mode.
 *
 * @extends {stream.Transform}
 */

var Encoder = function (_stream$Transform) {
  _inherits(Encoder, _stream$Transform);

  /**
   * Creates an instance of Encoder.
   *
   * @param {Object} [options={}] - options for the encoder
   * @param {any[]} [options.genTypes=[]] - array of pairs of `type`,
   *   `function(Encoder)` for semantic types to be encoded.  Not needed
   *   for Array, Date, Buffer, Map, RegExp, Set, Url, or bignumber.
   * @param {boolean} [options.canonical=false] - should the output be
   *   canonicalized
   * @param {boolean|Symbol} [options.detectLoops=false] - should object loops
   *   be detected?  This will currently modify the encoded object graph
   *   by adding a Symbol property to each object.  If this bothers you,
   *   call `removeLoopDetectors` on the encoded object when done.  Do not
   *   encode the same object twice on the same encoder, without calling
   *   `removeLoopDetectors` in between.
   */
  function Encoder(options) {
    _classCallCheck(this, Encoder);

    options = options || {};
    options.readableObjectMode = false;
    options.writableObjectMode = true;

    var _this = _possibleConstructorReturn(this, _stream$Transform.call(this, options));

    _this.canonical = options.canonical;
    // new Symbol for each instance.  Note: means we can't re-use the same
    // encoder and encoded object
    if (_typeof(options.detectLoops) === 'symbol') {
      _this.detectLoops = options.detectLoops;
    } else {
      _this.detectLoops = !!options.detectLoops ? Symbol('CBOR_DETECT') : null;
    }

    _this.semanticTypes = [Array, _this._pushArray, Date, _this._pushDate, Buffer, _this._pushBuffer, Map, _this._pushMap, NoFilter, _this._pushNoFilter, RegExp, _this._pushRegexp, Set, _this._pushSet, url.Url, _this._pushUrl, bignumber, _this._pushBigNumber];

    var addTypes = options.genTypes || [];
    for (var i = 0, len = addTypes.length; i < len; i += 2) {
      _this.addSemanticType(addTypes[i], addTypes[i + 1]);
    }
    return _this;
  }

  Encoder.prototype._transform = function _transform(fresh, encoding, cb) {
    var ret = this.pushAny(fresh);
    // Old transformers might not return bool.  undefined !== false
    return cb(ret === false ? new Error('Push Error') : undefined);
  };

  Encoder.prototype._flush = function _flush(cb) {
    return cb();
  };

  /**
   * @callback encodeFunction
   * @param {Encoder} encoder - the encoder to serialize into.  Call "write"
   *   on the encoder as needed.
   * @return {bool} - true on success, else false
   */

  /**
   * Add an encoding function to the list of supported semantic types.  This is
   * useful for objects for which you can't add an encodeCBOR method
   *
   * @param {any} type
   * @param {any} fun
   * @returns {encodeFunction}
   */


  Encoder.prototype.addSemanticType = function addSemanticType(type, fun) {
    for (var i = 0, len = this.semanticTypes.length; i < len; i += 2) {
      var typ = this.semanticTypes[i];
      if (typ === type) {
        var old = this.semanticTypes[i + 1];
        this.semanticTypes[i + 1] = fun;
        return old;
      }
    }
    this.semanticTypes.push(type, fun);
    return null;
  };

  Encoder.prototype._pushUInt8 = function _pushUInt8(val) {
    var b = new Buffer(1);
    b.writeUInt8(val);
    return this.push(b);
  };

  Encoder.prototype._pushUInt16BE = function _pushUInt16BE(val) {
    var b = new Buffer(2);
    b.writeUInt16BE(val);
    return this.push(b);
  };

  Encoder.prototype._pushUInt32BE = function _pushUInt32BE(val) {
    var b = new Buffer(4);
    b.writeUInt32BE(val);
    return this.push(b);
  };

  Encoder.prototype._pushDoubleBE = function _pushDoubleBE(val) {
    var b = new Buffer(8);
    b.writeDoubleBE(val);
    return this.push(b);
  };

  Encoder.prototype._pushNaN = function _pushNaN() {
    return this.push(BUF_NAN);
  };

  Encoder.prototype._pushInfinity = function _pushInfinity(obj) {
    var half = obj < 0 ? BUF_INF_NEG : BUF_INF_POS;
    return this.push(half);
  };

  Encoder.prototype._pushFloat = function _pushFloat(obj) {
    if (this.canonical) {
      // TODO: is this enough slower to hide behind canonical?
      // It's certainly enough of a hack (see utils.parseHalf)

      // From section 3.9:
      // If a protocol allows for IEEE floats, then additional canonicalization
      // rules might need to be added.  One example rule might be to have all
      // floats start as a 64-bit float, then do a test conversion to a 32-bit
      // float; if the result is the same numeric value, use the shorter value
      // and repeat the process with a test conversion to a 16-bit float.  (This
      // rule selects 16-bit float for positive and negative Infinity as well.)

      // which seems pretty much backwards to me.
      var b2 = new Buffer(2);
      if (utils.writeHalf(b2, obj)) {
        if (utils.parseHalf(b2) === obj) {
          return this._pushUInt8(HALF) && this.push(b2);
        }
      }
      var b4 = new Buffer(4);
      b4.writeFloatBE(obj);
      if (b4.readFloatBE() === obj) {
        return this._pushUInt8(FLOAT) && this.push(b4);
      }
    }

    return this._pushUInt8(DOUBLE) && this._pushDoubleBE(obj);
  };

  Encoder.prototype._pushInt = function _pushInt(obj, mt, orig) {
    var m = mt << 5;
    switch (false) {
      case !(obj < 24):
        return this._pushUInt8(m | obj);
      case !(obj <= 0xff):
        return this._pushUInt8(m | NUMBYTES.ONE) && this._pushUInt8(obj);
      case !(obj <= 0xffff):
        return this._pushUInt8(m | NUMBYTES.TWO) && this._pushUInt16BE(obj);
      case !(obj <= 0xffffffff):
        return this._pushUInt8(m | NUMBYTES.FOUR) && this._pushUInt32BE(obj);
      case !(obj <= Number.MAX_SAFE_INTEGER):
        return this._pushUInt8(m | NUMBYTES.EIGHT) && this._pushUInt32BE(Math.floor(obj / SHIFT32)) && this._pushUInt32BE(obj % SHIFT32);
      default:
        if (mt === MT.NEG_INT) {
          return this._pushFloat(orig);
        } else {
          return this._pushFloat(obj);
        }
    }
  };

  Encoder.prototype._pushIntNum = function _pushIntNum(obj) {
    if (obj < 0) {
      return this._pushInt(-obj - 1, MT.NEG_INT, obj);
    } else {
      return this._pushInt(obj, MT.POS_INT);
    }
  };

  Encoder.prototype._pushNumber = function _pushNumber(obj) {
    switch (false) {
      case !isNaN(obj):
        return this._pushNaN(obj);
      case isFinite(obj):
        return this._pushInfinity(obj);
      case Math.round(obj) !== obj:
        return this._pushIntNum(obj);
      default:
        return this._pushFloat(obj);
    }
  };

  Encoder.prototype._pushString = function _pushString(obj) {
    var len = Buffer.byteLength(obj, 'utf8');
    return this._pushInt(len, MT.UTF8_STRING) && this.push(obj, 'utf8');
  };

  Encoder.prototype._pushBoolean = function _pushBoolean(obj) {
    return this._pushUInt8(obj ? TRUE : FALSE);
  };

  Encoder.prototype._pushUndefined = function _pushUndefined(obj) {
    return this._pushUInt8(UNDEFINED);
  };

  Encoder.prototype._pushNull = function _pushNull(obj) {
    return this._pushUInt8(NULL);
  };

  Encoder.prototype._pushArray = function _pushArray(gen, obj) {
    var len = obj.length;
    if (!gen._pushInt(len, MT.ARRAY)) {
      return false;
    }
    for (var j = 0; j < len; j++) {
      if (!gen.pushAny(obj[j])) {
        return false;
      }
    }
    return true;
  };

  Encoder.prototype._pushTag = function _pushTag(tag) {
    return this._pushInt(tag, MT.TAG);
  };

  Encoder.prototype._pushDate = function _pushDate(gen, obj) {
    return gen._pushTag(TAG.DATE_EPOCH) && gen.pushAny(obj / 1000);
  };

  Encoder.prototype._pushBuffer = function _pushBuffer(gen, obj) {
    return gen._pushInt(obj.length, MT.BYTE_STRING) && gen.push(obj);
  };

  Encoder.prototype._pushNoFilter = function _pushNoFilter(gen, obj) {
    return gen._pushBuffer(gen, obj.slice());
  };

  Encoder.prototype._pushRegexp = function _pushRegexp(gen, obj) {
    return gen._pushTag(TAG.REGEXP) && gen.pushAny(obj.source);
  };

  Encoder.prototype._pushSet = function _pushSet(gen, obj) {
    if (!gen._pushInt(obj.size, MT.ARRAY)) {
      return false;
    }
    for (var _iterator = obj, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {
      var _ref;

      if (_isArray) {
        if (_i >= _iterator.length) break;
        _ref = _iterator[_i++];
      } else {
        _i = _iterator.next();
        if (_i.done) break;
        _ref = _i.value;
      }

      var x = _ref;

      if (!gen.pushAny(x)) {
        return false;
      }
    }
    return true;
  };

  Encoder.prototype._pushUrl = function _pushUrl(gen, obj) {
    return gen._pushTag(TAG.URI) && gen.pushAny(obj.format());
  };

  Encoder.prototype._pushBigint = function _pushBigint(obj) {
    var tag = TAG.POS_BIGINT;
    if (obj.isNegative()) {
      obj = obj.negated().minus(1);
      tag = TAG.NEG_BIGINT;
    }
    var str = obj.toString(16);
    if (str.length % 2) {
      str = '0' + str;
    }
    var buf = new Buffer(str, 'hex');
    return this._pushTag(tag) && this._pushBuffer(this, buf);
  };

  Encoder.prototype._pushBigNumber = function _pushBigNumber(gen, obj) {
    if (obj.isNaN()) {
      return gen._pushNaN();
    }
    if (!obj.isFinite()) {
      return gen._pushInfinity(obj.isNegative() ? -Infinity : Infinity);
    }
    if (obj.isInteger()) {
      return gen._pushBigint(obj);
    }
    if (!(gen._pushTag(TAG.DECIMAL_FRAC) && gen._pushInt(2, MT.ARRAY))) {
      return false;
    }

    var dec = obj.decimalPlaces();
    var slide = obj.times(new bignumber(10).pow(dec));
    if (!gen._pushIntNum(-dec)) {
      return false;
    }
    if (slide.abs().isLessThan(MAXINT_BN)) {
      return gen._pushIntNum(slide.toNumber());
    } else {
      return gen._pushBigint(slide);
    }
  };

  Encoder.prototype._pushMap = function _pushMap(gen, obj) {
    if (!gen._pushInt(obj.size, MT.MAP)) {
      return false;
    }
    // memoizing the cbor only helps in certain cases, and hurts in most
    // others.  Just avoid it.
    if (gen.canonical) {
      // keep the key/value pairs together, so we don't have to do odd
      // gets with object keys later
      var entries = [];
      // iterator.  If we drop support for node4, use ...
      for (var _iterator2 = obj.entries(), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {
        var _ref2;

        if (_isArray2) {
          if (_i2 >= _iterator2.length) break;
          _ref2 = _iterator2[_i2++];
        } else {
          _i2 = _iterator2.next();
          if (_i2.done) break;
          _ref2 = _i2.value;
        }

        var e = _ref2;

        entries.push(e);
      }
      entries.sort(function (a, b) {
        // a, b are both entries of [key, value]
        var a_cbor = Encoder.encode(a[0]);
        var b_cbor = Encoder.encode(b[0]);
        return a_cbor.compare(b_cbor);
      });
      for (var _iterator3 = entries, _isArray3 = Array.isArray(_iterator3), _i3 = 0, _iterator3 = _isArray3 ? _iterator3 : _iterator3[Symbol.iterator]();;) {
        var _ref3;

        if (_isArray3) {
          if (_i3 >= _iterator3.length) break;
          _ref3 = _iterator3[_i3++];
        } else {
          _i3 = _iterator3.next();
          if (_i3.done) break;
          _ref3 = _i3.value;
        }

        var kv = _ref3;

        if (!(gen.pushAny(kv[0]) && gen.pushAny(kv[1]))) {
          return false;
        }
      }
    } else {
      for (var _iterator4 = obj, _isArray4 = Array.isArray(_iterator4), _i4 = 0, _iterator4 = _isArray4 ? _iterator4 : _iterator4[Symbol.iterator]();;) {
        var _ref4;

        if (_isArray4) {
          if (_i4 >= _iterator4.length) break;
          _ref4 = _iterator4[_i4++];
        } else {
          _i4 = _iterator4.next();
          if (_i4.done) break;
          _ref4 = _i4.value;
        }

        var _kv = _ref4;

        if (!(gen.pushAny(_kv[0]) && gen.pushAny(_kv[1]))) {
          return false;
        }
      }
    }
    return true;
  };

  Encoder.prototype.removeLoopDetectors = function removeLoopDetectors(obj) {
    if (!this.detectLoops || (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object' || !obj) {
      return false;
    }
    var dl = obj[LOOP_DETECT];
    if (!dl || dl !== this.detectLoops) {
      // ironically, use loop marking to detect loops on removal as well
      return false;
    }
    delete obj[LOOP_DETECT];
    if (Array.isArray(obj)) {
      for (var _iterator5 = obj, _isArray5 = Array.isArray(_iterator5), _i5 = 0, _iterator5 = _isArray5 ? _iterator5 : _iterator5[Symbol.iterator]();;) {
        var _ref5;

        if (_isArray5) {
          if (_i5 >= _iterator5.length) break;
          _ref5 = _iterator5[_i5++];
        } else {
          _i5 = _iterator5.next();
          if (_i5.done) break;
          _ref5 = _i5.value;
        }

        var i = _ref5;

        this.removeLoopDetectors(i);
      }
    } else {
      for (var k in obj) {
        this.removeLoopDetectors(obj[k]);
      }
    }
    return true;
  };

  Encoder.prototype._pushObject = function _pushObject(obj) {
    if (!obj) {
      return this._pushNull(obj);
    }
    if (this.detectLoops) {
      if (obj[LOOP_DETECT] === this.detectLoops) {
        throw new Error('Loop detected while CBOR encoding');
      } else {
        obj[LOOP_DETECT] = this.detectLoops;
      }
    }
    var f = obj.encodeCBOR;
    if (typeof f === 'function') {
      return f.call(obj, this);
    }
    for (var i = 0, len1 = this.semanticTypes.length; i < len1; i += 2) {
      var typ = this.semanticTypes[i];
      if (obj instanceof typ) {
        return this.semanticTypes[i + 1].call(obj, this, obj);
      }
    }
    var keys = Object.keys(obj);
    var cbor_keys = {};
    if (this.canonical) {
      // note: this can't be a normal sort, because 'b' needs to sort before
      // 'aa'
      keys.sort(function (a, b) {
        // Always strings, so don't bother to pass options.
        // hold on to the cbor versions, since there's no need
        // to encode more than once
        var a_cbor = cbor_keys[a] || (cbor_keys[a] = Encoder.encode(a));
        var b_cbor = cbor_keys[b] || (cbor_keys[b] = Encoder.encode(b));

        return a_cbor.compare(b_cbor);
      });
    }
    if (!this._pushInt(keys.length, MT.MAP)) {
      return false;
    }
    var ck = void 0;
    for (var j = 0, len2 = keys.length; j < len2; j++) {
      var k = keys[j];
      if (this.canonical && (ck = cbor_keys[k])) {
        if (!this.push(ck)) {
          // already a Buffer
          return false;
        }
      } else {
        if (!this._pushString(k)) {
          return false;
        }
      }
      if (!this.pushAny(obj[k])) {
        return false;
      }
    }

    return true;
  };

  /**
   * Push any supported type onto the encoded stream
   *
   * @param {any} obj
   * @returns {boolean} true on success
   */


  Encoder.prototype.pushAny = function pushAny(obj) {
    switch (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) {
      case 'number':
        return this._pushNumber(obj);
      case 'string':
        return this._pushString(obj);
      case 'boolean':
        return this._pushBoolean(obj);
      case 'undefined':
        return this._pushUndefined(obj);
      case 'object':
        return this._pushObject(obj);
      case 'symbol':
        switch (obj) {
          case SYMS.NULL:
            return this._pushNull(null);
          case SYMS.UNDEFINED:
            return this._pushUndefined(void 0);
          // TODO: Add pluggable support for other symbols
          default:
            throw new Error('Unknown symbol: ' + obj.toString());
        }
      default:
        throw new Error('Unknown type: ' + (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) + ', ' + (!!obj ? obj.toString() : ''));
    }
  };

  /* backwards-compat wrapper */


  Encoder.prototype._pushAny = function _pushAny(obj) {
    // TODO: write deprecation warning
    return this.pushAny(obj);
  };

  Encoder.prototype._encodeAll = function _encodeAll(objs) {
    var bs = new NoFilter();
    this.pipe(bs);
    for (var _iterator6 = objs, _isArray6 = Array.isArray(_iterator6), _i6 = 0, _iterator6 = _isArray6 ? _iterator6 : _iterator6[Symbol.iterator]();;) {
      var _ref6;

      if (_isArray6) {
        if (_i6 >= _iterator6.length) break;
        _ref6 = _iterator6[_i6++];
      } else {
        _i6 = _iterator6.next();
        if (_i6.done) break;
        _ref6 = _i6.value;
      }

      var o = _ref6;

      if (typeof o === 'undefined') {
        this._pushUndefined();
      } else if (o === null) {
        this._pushNull(null);
      } else {
        this.write(o);
      }
    }
    this.end();
    return bs.read();
  };

  /**
   * Encode one or more JavaScript objects, and return a Buffer containing the
   * CBOR bytes.
   *
   * @param {...any} objs - the objects to encode
   * @returns {Buffer} - the encoded objects
   */


  Encoder.encode = function encode() {
    var objs = Array.prototype.slice.apply(arguments);
    return new Encoder()._encodeAll(objs);
  };

  /**
   * Encode one or more JavaScript objects canonically (slower!), and return
   * a Buffer containing the CBOR bytes.
   *
   * @param {...any} objs - the objects to encode
   * @returns {Buffer} - the encoded objects
   */


  Encoder.encodeCanonical = function encodeCanonical() {
    var objs = Array.prototype.slice.apply(arguments);
    return new Encoder({ canonical: true })._encodeAll(objs);
  };

  return Encoder;
}(stream.Transform);

module.exports = Encoder;
