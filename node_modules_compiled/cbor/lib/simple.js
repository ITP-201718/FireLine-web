'use strict';

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var constants = require('./constants');
var MT = constants.MT;
var SIMPLE = constants.SIMPLE;
var SYMS = constants.SYMS;

/**
 * A CBOR Simple Value that does not map onto a known constant.
 */

var Simple = function () {
  /**
   * Creates an instance of Simple.
   *
   * @param {integer} value - the simple value's integer value
   */
  function Simple(value) {
    _classCallCheck(this, Simple);

    if (typeof value !== 'number') {
      throw new Error('Invalid Simple type: ' + (typeof value === 'undefined' ? 'undefined' : _typeof(value)));
    }
    if (value < 0 || value > 255 || (value | 0) !== value) {
      throw new Error('value must be a small positive integer: ' + value);
    }
    this.value = value;
  }

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */


  Simple.prototype.toString = function toString() {
    return 'simple(' + this.value + ')';
  };

  /**
   * Debug string for simple value
   *
   * @returns {string} simple(value)
   */


  Simple.prototype.inspect = function inspect(depth, opts) {
    return 'simple(' + this.value + ')';
  };

  /**
   * Push the simple value onto the CBOR stream
   *
   * @param {cbor.Encoder} gen The generator to push onto
   */


  Simple.prototype.encodeCBOR = function encodeCBOR(gen) {
    return gen._pushInt(this.value, MT.SIMPLE_FLOAT);
  };

  /**
   * Is the given object a Simple?
   *
   * @param {any} obj - object to test
   * @returns {bool} - is it Simple?
   */


  Simple.isSimple = function isSimple(obj) {
    return obj instanceof Simple;
  };

  /**
   * Decode from the CBOR additional information into a JavaScript value.
   * If the CBOR item has no parent, return a "safe" symbol instead of
   * `null` or `undefined`, so that the value can be passed through a
   * stream in object mode.
   *
   * @param {number} val - the CBOR additional info to convert
   * @param {bool} has_parent - Does the CBOR item have a parent?
   * @returns {(null|undefined|bool|Symbol)} - the decoded value
   */


  Simple.decode = function decode(val, has_parent) {
    if (has_parent == null) {
      has_parent = true;
    }
    switch (val) {
      case SIMPLE.FALSE:
        return false;
      case SIMPLE.TRUE:
        return true;
      case SIMPLE.NULL:
        if (has_parent) {
          return null;
        } else {
          return SYMS.NULL;
        }
      case SIMPLE.UNDEFINED:
        if (has_parent) {
          return void 0;
        } else {
          return SYMS.UNDEFINED;
        }
      case -1:
        if (!has_parent) {
          throw new Error('Invalid BREAK');
        }
        return SYMS.BREAK;
      default:
        return new Simple(val);
    }
  };

  return Simple;
}();

module.exports = Simple;
